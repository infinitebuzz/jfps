<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
		"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:x2="http://www.w3.org/TR/xhtml2" xmlns:role=
"http://www.w3.org/2005/01/wai-rdf/GUIRoleTaxonomy#" xmlns:state="http://www.w3.org/2005/07/aaa">
<!-- this validate fails in the javascript -->
<head>
  <title>jFPS</title>
  <link rel="stylesheet" type="text/css" href="css/jfps.css" />
  <script type="text/javascript" src="js/jfps.js"></script>
  <script type="text/javascript" src="js/map0.js"></script>
  <script type="text/javascript" src="js/map1.js"></script>
</head>

<body>
  <canvas id="canvas" width="700" height="300"></canvas><br />
  <span id="instruct">Keys:  aswd zx m 12  </span><span id="stats">Initializing</span>
  <p id="map" style="font-family: 'Lucida Console', Monaco, monospace; font-size: 7px;"></p>
  <script type="text/javascript">
  /* Original source
  https://github.com/OneLoneCoder/videos/blob/master/OneLoneCoder_CommandLineFPS.cpp
  */
	var vendors = ['webkit', 'moz'];
	var canvas = document.getElementById("canvas");
	var divStats = document.getElementById("stats");
	var divMap = document.getElementById("map");
	var fShowMap = false;
	var fPlayerA = 0.0;			// Player Start Rotation
	var fFOV = 3.14159 / 4.0;	// Field of View
	var fDepth = 16.0;			// Maximum rendering distance
	var fSpeed = 0.01;			// Walking Speed
	
	// Create Map of world space # = wall block, . = space
	var map = map0;
	var nMapWidth = map0Width;				// World Dimensions
	var nMapHeight = map0Height;
	var fPlayerX = map0PlayerX;			// Player Start Position
	var fPlayerY = map0PlayerY;
/*
	var fPlayerX = 14.7;			// Player Start Position
	var fPlayerY = 5.09;
	var map = "";
	var nMapWidth = 16;				// World Dimensions
	var nMapHeight = 16;
	map += "#########       ";
	map += "#               ";
	map += "#       ########";
	map += "#              #";
	map += "#      ##      #";
	map += "#      ##      #";
	map += "#              #";
	map += "###            #";
	map += "##             #";
	map += "#      ####  ###";
	map += "#      #       #";
	map += "#      #       #";
	map += "#              #";
	map += "#      #########";
	map += "#              #";
	map += "################";
*/
	for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
		window.cancelAnimationFrame =
		  window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
	}

	var cw = canvas.width,
		ch = canvas.height,
		cx = null,
		fps = 30,
		fElapsedTime =    1000/fps,
		lastTime     =    (new Date()).getTime(),
		currentTime  =    0,
		delta = 0;
	var nScreenWidth = 100;			// Console Screen Size X (columns)
	var nScreenHeight = 100;			// Console Screen Size Y (rows)
	var blockSizeX = cw / nScreenWidth;
	var blockSizeY = ch / nScreenHeight;


	function gameLoop() {
		window.requestAnimationFrame(gameLoop);

		currentTime = (new Date()).getTime();
		delta = (currentTime-lastTime);

		//if(delta > fElapsedTime) 
		{
			cx.clearRect(0,0,cw,cw);
			// draw

			for (var x = 0; x < nScreenWidth; x++)
			{
				// For each column, calculate the projected ray angle into world space
				var fRayAngle = (fPlayerA - fFOV/2.0) + (x / nScreenWidth) * fFOV;

				// Find distance to wall
				var fStepSize = 0.1;		  // Increment size for ray casting, decrease to increase										
				var fDistanceToWall = 0.0; //                                      resolution

				var bHitWall = false;		// Set when ray hits wall block
				var bBoundary = false;		// Set when ray hits boundary between two wall blocks

				var fEyeX = Math.sin(fRayAngle); // Unit vector for ray in player space
				var fEyeY = Math.cos(fRayAngle);

				// Incrementally cast ray from player, along ray angle, testing for 
				// intersection with a block
				while (!bHitWall && fDistanceToWall < fDepth)
				{
					fDistanceToWall += fStepSize;
					var nTestX = Math.floor(fPlayerX + fEyeX * fDistanceToWall);
					var nTestY = Math.floor(fPlayerY + fEyeY * fDistanceToWall);
					
					// Test if ray is out of bounds
					if (nTestX < 0 || nTestX >= nMapWidth || nTestY < 0 || nTestY >= nMapHeight)
					{
						bHitWall = true;			// Just set distance to maximum depth
						fDistanceToWall = fDepth;
					}
					else
					{
						// Ray is inbounds so test to see if the ray cell is a wall block
						if(map.charAt(nTestY * nMapWidth + nTestX) != ' ')
						{
							// Ray has hit wall
							bHitWall = true;

							// To highlight tile boundaries, cast a ray from each corner
							// of the tile, to the player. The more coincident this ray
							// is to the rendering ray, the closer we are to a tile 
							// boundary, which we'll shade to add detail to the walls
							var p = [];

							// Test each corner of hit tile, storing the distance from
							// the player, and the calculated dot product of the two rays
							var totalVectors = 0;
							for (var tx = 0; tx < 2; tx++)
								for (var ty = 0; ty < 2; ty++)
								{
									// Angle of corner to eye
									var vy = nTestY + ty - fPlayerY;
									var vx = nTestX + tx - fPlayerX;
									var d = Math.sqrt(vx*vx + vy*vy); 
									var dot = (fEyeX * vx / d) + (fEyeY * vy / d);
									p[totalVectors] = [d, dot];
									totalVectors++;
								}

							// Sort Pairs from closest to farthest
							p.sort(function(a, b) {
								return a[0] - b[0];
							});
			//				sort(p.begin(), p.end(), [](const pair<float, float> &left, const pair<float, float> &right) {return left.first < right.first; });
							
							// First two/three are closest (we will never see all four)
							var fBound = 0.01;
							if (Math.acos(p[0][1]) < fBound) bBoundary = true;
							if (Math.acos(p[1][1]) < fBound) bBoundary = true;
							if (Math.acos(p[2][1]) < fBound) bBoundary = true;
						}
					}
				}
			
				// Calculate distance to ceiling and floor
				var nCeiling = (nScreenHeight/2.0) - nScreenHeight / (fDistanceToWall);
				var nFloor = nScreenHeight - nCeiling;

				// Shader walls based on distance
				var nShade = '#FFFFFF';
				var nLight = 0
				if (fDistanceToWall > fDepth) {
					nShade = '#000000';	// Out of range
				}
				else 
				{
					nLight = (1.0 - (fDistanceToWall / fDepth)) * 172;
				}
				switch(map.charAt(nTestY * nMapWidth + nTestX)) {
				default:
				case '#':
					nShade = "rgb("+nLight+","+nLight+","+nLight+")"
					break;
				case ':':
					nShade = "rgb("+(nLight*0.1)+","+(nLight*0.9)+","+(nLight*0.2)+")"
					break;
				case ';':
					nShade = "rgb("+(nLight*0.6)+","+(nLight*0.3)+","+(nLight*0.6)+")"
					break;
				case ',':
					nShade = "rgb("+(nLight*0.2)+","+(nLight*0.4)+","+(nLight*0.4)+")"
					break;
				case '+':
					nShade = "rgb("+(nLight*0.4)+","+(nLight*0.2)+","+(nLight*0.2)+")"
					break;
				case '.':
					nShade = "rgb("+(nLight*0.6)+","+(nLight*0.4)+","+(nLight*0.6)+")"
					break;
				case '`':
					nShade = "rgb("+(nLight*0.7)+","+(nLight*0.7)+","+(nLight*0.7)+")"
					break;
				case '`':
					nShade = "rgb("+(nLight*0.0)+","+(nLight*0.9)+","+(nLight*0.9)+")"
					break;
				case '\\':
					nShade = "rgb("+(nLight*0.1)+","+(nLight*0.7)+","+(nLight*0.9)+")"
					break;
				case '@':
					nShade = "rgb("+(nLight*0.5)+","+(nLight*0.6)+","+(nLight*0.7)+")"
					break;
				}
				if (bBoundary)		nShade = '#000000'; // Black it out
				
				var drawX = nScreenWidth - x;
				for (var y = 0; y < nScreenHeight; y++)
				{
					// Each Row
					if(y <= nCeiling) {
						//var nCeilColor = (nCeiling - y) * 2;
						//cx.fillStyle = "rgb("+nCeilColor+","+nCeilColor+","+nCeilColor+")";
						cx.fillStyle = '#101010';
					} else if(y > nFloor) {
// Shade floor based on distance
						var b = ((y -nScreenHeight/2.0) / (nScreenHeight / 2.0));
						var nFloorColor = (b * 0.5) * 255;
						cx.fillStyle = "rgb("+nFloorColor*0.1+","+nFloorColor+","+nFloorColor*0.2+")";
					}
					else
					{				
						cx.fillStyle = nShade;
					}
					//cx.fillRect(x, y, blockSizeX, blockSizeY);
					cx.fillRect(drawX * blockSizeX, y * blockSizeY, blockSizeX, blockSizeY);
				}
			}

			// Display Stats
			//swprintf_s(screen, 40, L"X=%3.2f, Y=%3.2f, A=%3.2f FPS=%3.2f ", fPlayerX, fPlayerY, fPlayerA, 1.0f/fElapsedTime);
			divStats.innerHTML = "X=" + Math.round(fPlayerX * 100) / 100 + ", Y=" + Math.round(fPlayerY * 100) / 100 + ", A=" + Math.round((fPlayerA * 6.28319) * 100) / 100 + "fps=" + Math.round((1000/delta)*100)/100;
			
			if(fShowMap) {
				// Display Map
				screen = "";
				nPlayerX = Math.floor(fPlayerX);
				nPlayerY = Math.floor(fPlayerY);
				for (var ny = 0; ny < nMapHeight; ny++)
				{
					for (var nx = 0; nx < nMapWidth; nx++) 
					{
						if(nx == nPlayerX && ny == nPlayerY) {
							screen += 'P';
						} else if(map[ny * nMapWidth + nx] != ' ') {
							screen += '#';//map[ny * nMapWidth + nx];
						} else {
							screen += '_';
						}
					}
					screen += "<br />";
				}

				// Display Frame
				//screen[nScreenWidth * nScreenHeight - 1] = '\0';
				divMap.innerHTML = screen;
			}		
			lastTime = currentTime - (delta % fElapsedTime);
		}
	}

	document.addEventListener("keypress", function(event) {
		switch(event.keyCode) {
		case 97://'a':
			// left
			fPlayerA += (fSpeed * 5);// * fElapsedTime;
			break;
		case 100://'d':
			// right
			fPlayerA -= (fSpeed * 5);// * fElapsedTime;
			break;
		case 119://'w':
			// up
			fPlayerX += Math.sin(fPlayerA) * fSpeed * fElapsedTime;
			fPlayerY += Math.cos(fPlayerA) * fSpeed * fElapsedTime;
			if(map.charAt(Math.floor(fPlayerY) * nMapWidth + Math.floor(fPlayerX)) != ' ')
			{
				fPlayerX -= Math.sin(fPlayerA) * fSpeed * fElapsedTime;
				fPlayerY -= Math.cos(fPlayerA) * fSpeed * fElapsedTime;
			}
			break;
		case 115://'s':
			// down
			fPlayerX -= Math.sin(fPlayerA) * fSpeed * fElapsedTime;
			fPlayerY -= Math.cos(fPlayerA) * fSpeed * fElapsedTime;
			if(map.charAt(Math.floor(fPlayerY) * nMapWidth + Math.floor(fPlayerX)) != ' ')
			{
				fPlayerX += Math.sin(fPlayerA) * fSpeed * fElapsedTime;
				fPlayerY += Math.cos(fPlayerA) * fSpeed * fElapsedTime;
			}
			break;
		case 32:
			// Space - fire
			break;
		case 122:
			// Z - strafe left
			fPlayerX -= Math.sin(fPlayerA) * fSpeed * fElapsedTime;;
			fPlayerY += Math.cos(fPlayerA) * fSpeed * fElapsedTime;;
			if(map.charAt(Math.floor(fPlayerY) * nMapWidth + Math.floor(fPlayerX)) != ' ')
			{
				fPlayerX += Math.sin(fPlayerA) * fSpeed * fElapsedTime;;
				fPlayerY -= Math.cos(fPlayerA) * fSpeed * fElapsedTime;;
			}
			break;
		case 120:
			// x - strafe right
			fPlayerX += Math.sin(fPlayerA) * fSpeed * fElapsedTime;;
			fPlayerY -= Math.cos(fPlayerA) * fSpeed * fElapsedTime;;
			if(map.charAt(Math.floor(fPlayerY) * nMapWidth + Math.floor(fPlayerX)) != ' ')
			{
				fPlayerX -= Math.sin(fPlayerA) * fSpeed * fElapsedTime;;
				fPlayerY += Math.cos(fPlayerA) * fSpeed * fElapsedTime;;
			}
			break;
			// show hid map
		case 109:
			fShowMap = !fShowMap;
			if(!fShowMap) {
				divMap.innerHTML = "";
			}
			break;
			// change maps
		case 49:	//1
			map = map0;
			nMapWidth = map0Width;				// World Dimensions
			nMapHeight = map0Height;
			fPlayerX = map0PlayerX;			// Player Start Position
			fPlayerY = map0PlayerY;
			break;
		case 50:	//2
			map = map1;
			nMapWidth = map1Width;				// World Dimensions
			nMapHeight = map1Height;
			fPlayerX = map1PlayerX;			// Player Start Position
			fPlayerY = map1PlayerY;
			break;

		}
	})
	
	if (typeof (canvas.getContext) !== undefined) {
		cx = canvas.getContext('2d');

		gameLoop();
	}
  </script>
</body>
